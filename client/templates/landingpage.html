<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <link href="https://fonts.googleapis.com/css2?family=Montserrat:wght@300;400;500;700&display=swap" rel="stylesheet">
    <title>Olyium</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }
        
        body {
            font-family: 'Montserrat', sans-serif;
            color: #f0f0f0;
            min-height: 100vh;
            display: flex;
            align-items: center;
            justify-content: center;
            overflow: hidden;
            position: relative;
            background-color: #080810;
        }
        
        #canvas {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            z-index: -1;
        }
        
        .overlay {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: radial-gradient(circle at 50% 50%, rgba(8, 8, 16, 0) 0%, rgba(8, 8, 16, 0.4) 100%);
            z-index: 0;
            pointer-events: none;
        }
        
        .noise {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background-image: url("data:image/svg+xml,%3Csvg viewBox='0 0 1024 1024' xmlns='http://www.w3.org/2000/svg'%3E%3Cfilter id='noiseFilter'%3E%3CfeTurbulence type='fractalNoise' baseFrequency='0.85' numOctaves='5' stitchTiles='stitch'/%3E%3C/filter%3E%3Crect width='100%25' height='100%25' filter='url(%23noiseFilter)' opacity='0.05'/%3E%3C/svg%3E");
            opacity: 0.15;
            z-index: 1;
            pointer-events: none;
            mix-blend-mode: overlay;
        }
        
        .container {
            position: relative;
            z-index: 2;
            text-align: center;
        }
        
        .logo {
            font-size: 8rem;
            font-weight: 700;
            background: linear-gradient(135deg, #ffffff 0%, #aaaaaa 100%);
            -webkit-background-clip: text;
            background-clip: text;
            color: transparent;
            letter-spacing: 2px;
            text-transform: lowercase;
            position: relative;
            display: inline-block;
            animation: pulse 8s infinite ease-in-out;
            filter: drop-shadow(0 0 8px rgba(255, 255, 255, 0.1));
        }
        
        .logo::after {
            content: '';
            position: absolute;
            bottom: -10px;
            left: 25%;
            width: 50%;
            height: 1px;
            background: linear-gradient(90deg, transparent, rgba(255, 255, 255, 0.5), transparent);
            animation: expand 3s infinite alternate;
        }
        
        @keyframes pulse {
            0%, 100% { transform: scale(1); }
            50% { transform: scale(1.05); }
        }
        
        @keyframes expand {
            0% {
                width: 30%;
                left: 35%;
                opacity: 0.3;
            }
            100% {
                width: 60%;
                left: 20%;
                opacity: 0.8;
            }
        }
        
        @media (max-width: 768px) {
            .logo {
                font-size: 5rem;
            }
        }
    </style>
</head>
<body>
    <canvas id="canvas"></canvas>
    <div class="overlay"></div>
    <div class="noise"></div>
    <div class="container">
        <h1 class="logo">olyium</h1>
    </div>
    
    <script>
        const canvas = document.getElementById('canvas');
        const gl = canvas.getContext('webgl') || canvas.getContext('experimental-webgl');
        
        if (!gl) {
            document.body.innerHTML = '<div style="text-align: center; padding: 50px;">Your browser does not support WebGL</div>';
        }
        
        function resizeCanvas() {
            canvas.width = window.innerWidth * window.devicePixelRatio;
            canvas.height = window.innerHeight * window.devicePixelRatio;
            canvas.style.width = window.innerWidth + 'px';
            canvas.style.height = window.innerHeight + 'px';
            gl.viewport(0, 0, canvas.width, canvas.height);
        }
        
        window.addEventListener('resize', resizeCanvas);
        resizeCanvas();
        
        const vsSource = `
            attribute vec4 aVertexPosition;
            attribute vec2 aTextureCoord;
            
            varying highp vec2 vTextureCoord;
            
            void main(void) {
                gl_Position = aVertexPosition;
                vTextureCoord = aTextureCoord;
            }
        `;
        
        const fsSource = `
            precision highp float;
            varying highp vec2 vTextureCoord;
            
            uniform float uTime;
            uniform vec2 uResolution;
            uniform vec2 uMouse;
            
            #define PI 3.14159265359
            
            vec3 permute(vec3 x) { return mod(((x*34.0)+1.0)*x, 289.0); }
            
            float snoise(vec2 v) {
                const vec4 C = vec4(0.211324865405187, 0.366025403784439,
                        -0.577350269189626, 0.024390243902439);
                vec2 i  = floor(v + dot(v, C.yy));
                vec2 x0 = v -   i + dot(i, C.xx);
                vec2 i1;
                i1 = (x0.x > x0.y) ? vec2(1.0, 0.0) : vec2(0.0, 1.0);
                vec4 x12 = x0.xyxy + C.xxzz;
                x12.xy -= i1;
                i = mod(i, 289.0);
                vec3 p = permute( permute( i.y + vec3(0.0, i1.y, 1.0 ))
                + i.x + vec3(0.0, i1.x, 1.0 ));
                vec3 m = max(0.5 - vec3(dot(x0,x0), dot(x12.xy,x12.xy),
                    dot(x12.zw,x12.zw)), 0.0);
                m = m*m;
                m = m*m;
                vec3 x = 2.0 * fract(p * C.www) - 1.0;
                vec3 h = abs(x) - 0.5;
                vec3 ox = floor(x + 0.5);
                vec3 a0 = x - ox;
                m *= 1.79284291400159 - 0.85373472095314 * ( a0*a0 + h*h );
                vec3 g;
                g.x  = a0.x  * x0.x  + h.x  * x0.y;
                g.yz = a0.yz * x12.xz + h.yz * x12.yw;
                return 130.0 * dot(m, g);
            }
            
            float hash(vec2 p) {
                p = fract(p * vec2(123.34, 456.21));
                p += dot(p, p + 45.32);
                return fract(p.x * p.y);
            }
            
            float noise(vec2 p) {
                vec2 i = floor(p);
                vec2 f = fract(p);
                f = f * f * (3.0 - 2.0 * f);
                
                float a = hash(i);
                float b = hash(i + vec2(1.0, 0.0));
                float c = hash(i + vec2(0.0, 1.0));
                float d = hash(i + vec2(1.0, 1.0));
                
                return mix(mix(a, b, f.x), mix(c, d, f.x), f.y);
            }
            
            float fbm(vec2 p) {
                float value = 0.0;
                float amplitude = 0.5;
                float frequency = 1.0;
                
                for (int i = 0; i < 8; i++) {
                    value += amplitude * snoise(p * frequency);
                    p = p * 1.1 + vec2(0.7, 0.8);
                    frequency *= 2.0;
                    amplitude *= 0.5;
                }
                return value * 0.5 + 0.5;
            }
            
            float pattern(vec2 p, float time) {
                vec2 q = vec2(
                    fbm(p + vec2(0.0, 0.0) + 0.1 * time),
                    fbm(p + vec2(5.2, 1.3) + 0.2 * time)
                );
                
                vec2 r = vec2(
                    fbm(p + 4.0 * q + vec2(1.7, 9.2) + 0.15 * time),
                    fbm(p + 4.0 * q + vec2(8.3, 2.8) + 0.126 * time)
                );
                
                return fbm(p + 4.0 * r);
            }
            
            vec3 hsv2rgb(vec3 c) {
                vec4 K = vec4(1.0, 2.0 / 3.0, 1.0 / 3.0, 3.0);
                vec3 p = abs(fract(c.xxx + K.xyz) * 6.0 - K.www);
                return c.z * mix(K.xxx, clamp(p - K.xxx, 0.0, 1.0), c.y);
            }
            
            float dither8x8(vec2 position, float brightness) {
                int x = int(mod(position.x, 8.0));
                int y = int(mod(position.y, 8.0));
                int index = x + y * 8;
                float limit = 0.0;
                
                if (x < 8) {
                    if (index == 0) limit = 0.015625;
                    if (index == 1) limit = 0.515625;
                    if (index == 2) limit = 0.140625;
                    if (index == 3) limit = 0.640625;
                    if (index == 4) limit = 0.046875;
                    if (index == 5) limit = 0.546875;
                    if (index == 6) limit = 0.171875;
                    if (index == 7) limit = 0.671875;
                    if (index == 8) limit = 0.765625;
                    if (index == 9) limit = 0.265625;
                    if (index == 10) limit = 0.890625;
                    if (index == 11) limit = 0.390625;
                    if (index == 12) limit = 0.796875;
                    if (index == 13) limit = 0.296875;
                    if (index == 14) limit = 0.921875;
                    if (index == 15) limit = 0.421875;
                    if (index == 16) limit = 0.203125;
                    if (index == 17) limit = 0.703125;
                    if (index == 18) limit = 0.078125;
                    if (index == 19) limit = 0.578125;
                    if (index == 20) limit = 0.234375;
                    if (index == 21) limit = 0.734375;
                    if (index == 22) limit = 0.109375;
                    if (index == 23) limit = 0.609375;
                    if (index == 24) limit = 0.953125;
                    if (index == 25) limit = 0.453125;
                    if (index == 26) limit = 0.828125;
                    if (index == 27) limit = 0.328125;
                    if (index == 28) limit = 0.984375;
                    if (index == 29) limit = 0.484375;
                    if (index == 30) limit = 0.859375;
                    if (index == 31) limit = 0.359375;
                    if (index == 32) limit = 0.0625;
                    if (index == 33) limit = 0.5625;
                    if (index == 34) limit = 0.1875;
                    if (index == 35) limit = 0.6875;
                    if (index == 36) limit = 0.03125;
                    if (index == 37) limit = 0.53125;
                    if (index == 38) limit = 0.15625;
                    if (index == 39) limit = 0.65625;
                    if (index == 40) limit = 0.8125;
                    if (index == 41) limit = 0.3125;
                    if (index == 42) limit = 0.9375;
                    if (index == 43) limit = 0.4375;
                    if (index == 44) limit = 0.78125;
                    if (index == 45) limit = 0.28125;
                    if (index == 46) limit = 0.90625;
                    if (index == 47) limit = 0.40625;
                    if (index == 48) limit = 0.25;
                    if (index == 49) limit = 0.75;
                    if (index == 50) limit = 0.125;
                    if (index == 51) limit = 0.625;
                    if (index == 52) limit = 0.21875;
                    if (index == 53) limit = 0.71875;
                    if (index == 54) limit = 0.09375;
                    if (index == 55) limit = 0.59375;
                    if (index == 56) limit = 1.0;
                    if (index == 57) limit = 0.5;
                    if (index == 58) limit = 0.875;
                    if (index == 59) limit = 0.375;
                    if (index == 60) limit = 0.96875;
                    if (index == 61) limit = 0.46875;
                    if (index == 62) limit = 0.84375;
                    if (index == 63) limit = 0.34375;
                }
                
                return brightness < limit ? 0.0 : 1.0;
            }
            
            vec3 applyDither(vec2 position, vec3 color) {
                float brightness = (color.r + color.g + color.b) / 3.0;
                float ditheredBrightness = dither8x8(position, brightness);
                float factor = ditheredBrightness / max(brightness, 0.001);
                return color * factor;
            }
            
            void main() {
                vec2 uv = vTextureCoord;
                vec2 normalizedMouse = uMouse / uResolution;
                
                float aspect = uResolution.x / uResolution.y;
                uv.x *= aspect;
                
                vec2 center = vec2(aspect * 0.5, 0.5);
                center += (normalizedMouse - vec2(0.5, 0.5)) * 0.05;
                
                float dist = distance(uv, center);
                float slowTime = uTime * 0.05;
                
                vec3 darkBlue = vec3(0.03, 0.03, 0.1);
                vec3 mediumBlue = vec3(0.07, 0.07, 0.15);
                vec3 lightBlue = vec3(0.12, 0.12, 0.22);
                vec3 accentColor = vec3(0.15, 0.15, 0.3);
                
                float patternValue = pattern(uv * 0.7, slowTime);
                float smoothPattern = smoothstep(0.3, 0.7, patternValue);
                
                vec2 distortedUV = uv;
                distortedUV += vec2(
                    snoise(uv * 3.0 + slowTime * 0.5) * 0.02,
                    snoise(uv * 3.0 + vec2(1.0) + slowTime * 0.5) * 0.02
                );
                
                float distortedDist = distance(distortedUV, center);
                
                float gradientFactor = smoothstep(0.0, 1.8, distortedDist);
                vec3 baseColor = mix(mediumBlue, darkBlue, gradientFactor);
                
                float noiseValue = fbm(uv * 2.0 + vec2(sin(slowTime), cos(slowTime)) * 0.1);
                float smoothNoise = smoothstep(0.3, 0.7, noiseValue);
                
                vec3 finalColor = mix(baseColor, lightBlue, smoothPattern * 0.3);
                finalColor = mix(finalColor, accentColor, smoothNoise * 0.2);
                
                float vignette = smoothstep(0.0, 1.8, distortedDist);
                finalColor *= 1.0 - vignette * 0.5;
                
                float glow = smoothstep(0.6, 0.0, distortedDist);
                finalColor += accentColor * glow * 0.4;
                
                vec3 hsvColor = vec3(
                    0.6 + patternValue * 0.1 + slowTime * 0.02,
                    0.5 + smoothNoise * 0.2,
                    finalColor.b
                );
                
                vec3 colorShift = mix(finalColor, hsv2rgb(hsvColor), 0.3);
                finalColor = mix(finalColor, colorShift, smoothstep(0.4, 0.6, patternValue));
                
                float rays = 0.0;
                for (int i = 0; i < 5; i++) {
                    float angle = float(i) * PI / 2.5 + slowTime * 0.1;
                    vec2 rayDir = vec2(cos(angle), sin(angle));
                    float intensity = pow(abs(dot(normalize(uv - center), rayDir)), 32.0);
                    rays += intensity * 0.04;
                }
                
                finalColor += accentColor * rays;
                
                float antiAliasingFactor = 1.0 / max(length(vec2(dFdx(patternValue), dFdy(patternValue))), 0.001);
                finalColor = mix(finalColor, vec3(patternValue * 0.1 + 0.1), 0.1 * min(antiAliasingFactor, 1.0));
                
                gl_FragColor = vec4(finalColor, 1.0);
            }
        `;
        
        function initShaderProgram(gl, vsSource, fsSource) {
            const vertexShader = loadShader(gl, gl.VERTEX_SHADER, vsSource);
            const fragmentShader = loadShader(gl, gl.FRAGMENT_SHADER, fsSource);
            
            const shaderProgram = gl.createProgram();
            gl.attachShader(shaderProgram, vertexShader);
            gl.attachShader(shaderProgram, fragmentShader);
            gl.linkProgram(shaderProgram);
            
            if (!gl.getProgramParameter(shaderProgram, gl.LINK_STATUS)) {
                return null;
            }
            
            return shaderProgram;
        }
        
        function loadShader(gl, type, source) {
            const shader = gl.createShader(type);
            gl.shaderSource(shader, source);
            gl.compileShader(shader);
            
            if (!gl.getShaderParameter(shader, gl.COMPILE_STATUS)) {
                gl.deleteShader(shader);
                return null;
            }
            
            return shader;
        }
        
        function initBuffers(gl) {
            const positionBuffer = gl.createBuffer();
            gl.bindBuffer(gl.ARRAY_BUFFER, positionBuffer);
            
            const positions = [
                -1.0, -1.0,
                 1.0, -1.0,
                -1.0,  1.0,
                 1.0,  1.0,
            ];
            
            gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(positions), gl.STATIC_DRAW);
            
            const textureCoordBuffer = gl.createBuffer();
            gl.bindBuffer(gl.ARRAY_BUFFER, textureCoordBuffer);
            
            const textureCoordinates = [
                0.0, 0.0,
                1.0, 0.0,
                0.0, 1.0,
                1.0, 1.0,
            ];
            
            gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(textureCoordinates), gl.STATIC_DRAW);
            
            return {
                position: positionBuffer,
                textureCoord: textureCoordBuffer,
            };
        }
        
        function drawScene(gl, programInfo, buffers, time, mousePos) {
            gl.clearColor(0.0, 0.0, 0.0, 1.0);
            gl.clear(gl.COLOR_BUFFER_BIT);
            
            gl.bindBuffer(gl.ARRAY_BUFFER, buffers.position);
            gl.vertexAttribPointer(
                programInfo.attribLocations.vertexPosition,
                2,
                gl.FLOAT,
                false,
                0,
                0
            );
            gl.enableVertexAttribArray(programInfo.attribLocations.vertexPosition);
            
            gl.bindBuffer(gl.ARRAY_BUFFER, buffers.textureCoord);
            gl.vertexAttribPointer(
                programInfo.attribLocations.textureCoord,
                2,
                gl.FLOAT,
                false,
                0,
                0
            );
            gl.enableVertexAttribArray(programInfo.attribLocations.textureCoord);
            
            gl.uniform1f(programInfo.uniformLocations.time, time);
            gl.uniform2f(programInfo.uniformLocations.resolution, canvas.width, canvas.height);
            gl.uniform2f(programInfo.uniformLocations.mouse, mousePos.x, mousePos.y);
            
            gl.drawArrays(gl.TRIANGLE_STRIP, 0, 4);
        }
        
        const shaderProgram = initShaderProgram(gl, vsSource, fsSource);
        const programInfo = {
            program: shaderProgram,
            attribLocations: {
                vertexPosition: gl.getAttribLocation(shaderProgram, 'aVertexPosition'),
                textureCoord: gl.getAttribLocation(shaderProgram, 'aTextureCoord'),
            },
            uniformLocations: {
                time: gl.getUniformLocation(shaderProgram, 'uTime'),
                resolution: gl.getUniformLocation(shaderProgram, 'uResolution'),
                mouse: gl.getUniformLocation(shaderProgram, 'uMouse'),
            },
        };
        
        const buffers = initBuffers(gl);
        
        let mousePos = { x: 0, y: 0 };
        
        document.addEventListener('mousemove', (e) => {
            mousePos.x = e.clientX * window.devicePixelRatio;
            mousePos.y = canvas.height - e.clientY * window.devicePixelRatio;
            
            const logo = document.querySelector('.logo');
            const mouseXRatio = e.clientX / window.innerWidth;
            const mouseYRatio = e.clientY / window.innerHeight;
            logo.style.transform = `translate(${(mouseXRatio - 0.5) * 30}px, ${(mouseYRatio - 0.5) * 30}px)`;
        });
        
        let startTime = Date.now();
        
        function render() {
            const currentTime = (Date.now() - startTime) / 1000;
            
            gl.useProgram(programInfo.program);
            drawScene(gl, programInfo, buffers, currentTime, mousePos);
            
            requestAnimationFrame(render);
        }
        
        render();
    </script>
</body>
</html>
